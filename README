------------------------------------------
STRUCTURE
------------------------------------------
grid.lua            >> handles the creation of the grid, graphics and tiles/cell properties, as well as the
                       grids used by jumper for the path finding
player.lua          >> handles the player creation and some functions (like pee)
otherCharacter.lua  >> handles enemy creation and some function
levels.lua          >> visualizes the levels before starting the game
progress.lua        >> handles saving and loading progress
nextLevel.lua       >> handles the view if yo win or lose the level
constants.lua       >> configuration file for all the game variables, level variables included

main.lua            >> music and sounds loading, checking controls mode then takes you to the menu
menu.lua            >> view that allows you to choose to go to other pages
options.lua         >> allows to changes controls from pad to accelerometer
credits.lua         >> credits page, static


Game.lua

- The enemy dog is created using otherCharacter.lua 5 seconds after the start of the game
- I find the first free cell and place the enemy dog there
- I calculate the shortest path from the dog position to the first tree (wherever it is, it's not the closest one, just the first in the table)
- I use the calculated path to move there and collide with the tree


------------------------------------------
GRID LOGIC -------------------------------
------------------------------------------

--The grid is created in grid.lua at the beginning of the level (it's called in game.lua)
  grid.new()
    - the size of the screen and number of cells is calculated
    - the screen is filled with tiles of random obstacles
    - set the central tile as a path (with openPath) because the player will start from here
    - repeat this cicle until you reach pathTracerMoves (more moves, more path to walk, the easier is the game,
      parameter setted in level configuration)

      randomWalking()               >> choose a random direction and move there then turn the ending tile into
                                       a path with openPath
      openPath()                    >> change the tile and its properties to an open path that is walkable

    - count the remaining obstacles and give them a body
    transformObstaclesIntoTrees()   >> if a remaining obstacle is reachable, aka close to a path, then turn it
                                       into a tree (with a random image) until you have reached the number of
                                       trees for that level
    - return 3 grids: one complete (path, obstacles and properties), one with just the trees, one with just
      1 for obstacles and 0 for walkable to be used by jumper.


------------------------------------------
ENEMY LOGIC ------------------------------
------------------------------------------

--The enemy dog is created in game.lua only if visualizeEnemy = true in the level constants. It enters the
  screen, looks for a tree, goes there and pees on it till pee level reaches 0, then repeats the actions for as
  many trees as are setted in the configuration of the level (enemyPeeTrees). Pee velocity and stream are
  also configured in the level configuration (enemyPeeVelocity, peeStream)

  visualizeEnemyDog()
    whereToEnterTheEnemyDog()    >> chooses the first free cell on the grid to enter the dog
    findThePathToATree()         >> finds a random tree
    findClosestAvailableCell()   >> finds a free cell close to the tree (otherwise jumper doesn't work)
    findPath()                   >> finds the path to the tree/close-cell
    moveBasedOnPath()            >> moves the enemy dog to the tree/close-cell
                                    calcultes directions and the animation related to it with checkDirectionForAnimation()
    enemyDogPees()               >> repeats the pee action till the pee level is 0
    checkIfEnemyDogIsDone()      >> if the dog has done all the trees required goes back to the entry point
                                    and disappears otherwise looks for another target tree and goes there

--Pathfinding
  I used jumper
  Jumper creates a path between two available points but my end point is a tree and it's unavailable
  so I first had to find the closest available cell with function findClosestAvailableCell()

--Contrasting player
  When it reaches the tree it pees on it till the player pee level is 0 then moves to another tree

--collision with other dog
  This is handled on the main char function (player) since it already checks if it does collide with trees
  If it collides with the other dog it stops the level, visualizes another screen similar to the "lose" one


------------------------------------------
PROGRESS LOGIC ---------------------------
------------------------------------------

save()        >> checks last level saved if the current level is higher saves it otherwise not
                 (this allows replayability without deleating progresses)
load()        >> loads higher level saved
